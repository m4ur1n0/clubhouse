require "securerandom"

module BackendStepHelpers
  def named_users
    @named_users ||= {}
  end

  def named_clubs
    @named_clubs ||= {}
  end

  def user_named(name)
    named_users[name] ||= create(
      :user,
      name: name,
      email: "#{name.parameterize}@example.com",
      google_id: SecureRandom.uuid
    )
  end

  def club_named(name, owner_name = nil)
    return named_clubs[name] if named_clubs.key?(name)

    if (existing = Club.find_by(name: name))
      named_clubs[name] = existing
      return existing
    end

    owner = owner_name ? user_named(owner_name) : (@current_user || user_named("Owner"))
    named_clubs[name] = create(:club, name: name, user: owner)
  end

  def create_membership(user_name, club_name)
    Membership.find_or_create_by!(user: user_named(user_name), club: club_named(club_name))
  end
end

World(BackendStepHelpers)

Given("a signed in user {string}") do |name|
  @current_user = user_named(name)
  stub_current_user(@current_user)
end

Given("an existing club {string} owned by {string}") do |club_name, owner_name|
  @club = club_named(club_name, owner_name)
end

Given("another club {string} owned by {string}") do |club_name, owner_name|
  club_named(club_name, owner_name)
end

Given("the user {string} belongs to the club {string}") do |user_name, club_name|
  create_membership(user_name, club_name)
end

When("they submit a POST to create a club named {string} with description {string}") do |name, description|
  stub_current_user(@current_user)
  post clubs_path, { club: { name: name, description: description } }
  @last_response_status = last_response.status
  @club = Club.find_by!(name: name)
end

Then("the club {string} exists for {string}") do |club_name, owner_name|
  club = Club.find_by!(name: club_name)
  expect(club.user).to eq(user_named(owner_name))
end

Then("{string} is recorded as a member of {string}") do |user_name, club_name|
  club = Club.find_by!(name: club_name)
  expect(club.members.where(id: user_named(user_name).id).exists?).to be(true)
end

When("they submit a PATCH to update club {string} with description {string}") do |club_name, description|
  club = Club.find_by!(name: club_name)
  stub_current_user(club.user)
  patch club_path(club), { club: { description: description } }
  @last_response_status = last_response.status
end

Then("the club {string} has description {string}") do |club_name, description|
  expect(Club.find_by!(name: club_name).description).to eq(description)
end

When("they create an event named {string} scheduled for {string} at {string}") do |event_name, datetime, location|
  raise "Active club required" unless @club

  stub_current_user(@current_user)
  post club_events_path(@club), {
    event: {
      name: event_name,
      date: datetime,
      location: location,
      club_id: @club.id,
      description: "Autogenerated"
    }
  }
  @last_response_status = last_response.status
  @event = @club.events.order(created_at: :desc).find_by(name: event_name)
end

Then("the event {string} exists for {string}") do |event_name, club_name|
  club = Club.find_by!(name: club_name)
  event = club.events.find_by!(name: event_name)
  @event = event
end

Then("the event {string} lists {string} as attending") do |event_name, user_name|
  event = Event.find_by!(name: event_name)
  expect(event.users_attending).to include(user_named(user_name).id)
end

When("they create a recurring event named {string} scheduled for {string} ending on {string}") do |event_name, datetime, end_date|
  stub_current_user(@current_user)
  post club_events_path(@club), {
    event: {
      name: event_name,
      date: datetime,
      location: "Clubhouse",
      club_id: @club.id,
      recurring: "1",
      end_date: end_date,
      description: "Recurring"
    }
  }
  @last_response_status = last_response.status
end

When("they attempt to create a recurring event named {string} scheduled for {string} ending on {string}") do |event_name, datetime, end_date|
  step %(they create a recurring event named "#{event_name}" scheduled for "#{datetime}" ending on "#{end_date}")
end

Then("{int} events exist for {string}") do |count, event_name|
  expect(@club.events.where(name: event_name).count).to eq(count)
end

Then("each {string} event is owned by {string}") do |event_name, owner_name|
  owner = user_named(owner_name)
  events = @club.events.where(name: event_name)
  expect(events.pluck(:user_id).uniq).to eq([ owner.id ])
end

Then("the request is rejected") do
  expect(@last_response_status).to eq(422)
end

When("{string} joins the club {string}") do |user_name, club_name|
  @current_user = user_named(user_name)
  stub_current_user(@current_user)
  club = club_named(club_name)
  post club_membership_path(club)
  @last_response_status = last_response.status
end

When("{string} leaves the club {string}") do |user_name, club_name|
  user = user_named(user_name)
  club = club_named(club_name)
  create_membership(user_name, club_name)
  @current_user = user
  stub_current_user(@current_user)
  delete club_membership_path(club)
  @last_response_status = last_response.status
end

Then("{string} is no longer a member of {string}") do |user_name, club_name|
  club = club_named(club_name)
  expect(club.members.where(id: user_named(user_name).id)).to be_empty
end

When("they post a chat message {string} in {string}") do |content, club_name|
  club = club_named(club_name)
  stub_current_user(@current_user)
  post club_chat_messages_path(club), { chat_message: { content: content } }
  @last_response_status = last_response.status
  @chat_message = club.chat_messages.order(created_at: :desc).first
end

Then("a chat message exists in {string} with content {string}") do |club_name, content|
  club = club_named(club_name)
  message = club.chat_messages.find_by!(content: content)
  @chat_message = message
end

Given("an existing chat message {string} in {string}") do |content, club_name|
  club = club_named(club_name)
  @chat_message = create(:chat_message, club: club, user: @current_user, content: content)
end

When("they update the chat message to {string}") do |content|
  club = @chat_message.club
  stub_current_user(@chat_message.user)
  patch club_chat_message_path(club, @chat_message), { chat_message: { content: content } }
  @last_response_status = last_response.status
  @chat_message.reload
end

Then("the message content is {string}") do |content|
  expect(@chat_message.content).to eq(content)
end

Then("the message was flagged as edited") do
  expect(@chat_message.edited_at).to be_present
end
